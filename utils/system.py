import os
import signal
import subprocess
import timeit

import psutil
from loguru import logger

HOUR_TIMEOUT = 60 * 60
main_pid = psutil.Process().pid


class TimeoutException(Exception):
    def __init__(self, cmd, timeout):
        self.cmd = cmd
        self.timeout = timeout

    def __str__(self):
        return ("Command '%s' timed out after %s seconds" %
                (self.cmd, self.timeout))


def call_subprocess_internal(cmd: str, *, timeout: int):
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, preexec_fn=os.setsid)
    try:
        try:
            stdout, stderr = proc.communicate(timeout=timeout)
            if proc.returncode and proc.returncode != -9:
                raise subprocess.CalledProcessError(proc.returncode, f'{cmd} --> {stderr.decode(errors="ignore")}')
            return str(stdout, 'utf-8', errors='ignore')
        except subprocess.TimeoutExpired as ex:
            raise TimeoutException(ex.cmd, ex.timeout)
    finally:
        try:
            os.killpg(os.getpgid(proc.pid), signal.SIGKILL)
        except:
            pass


def call_subprocess(cmd, *, timeout=HOUR_TIMEOUT, disable_log=False):
    call_subprocess_output(cmd, timeout=timeout, disable_log=disable_log)


def call_subprocess_output(cmd, *, timeout=HOUR_TIMEOUT, disable_log=False) -> str:
    start_time = timeit.default_timer()
    not disable_log and logger.debug(f'cmd: {timeout}s {cmd}')
    try:
        output = call_subprocess_internal(cmd, timeout=timeout)
        elapsed = timeit.default_timer() - start_time
        not disable_log and logger.debug(f'cmd: {cmd} finished {"%.f" % elapsed}s')
        return output
    except TimeoutException as ex:
        logger.debug(f'cmd: {cmd} timeout after {timeout}s')
        raise ex
