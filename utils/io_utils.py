import functools
import os
import shutil
import uuid
from dataclasses import dataclass
from os import path, scandir
from pathlib import Path
from typing import List, Set

from .collections_utils import is_iterable
from .system import call_subprocess

DEFAULT_FOLDER = '/tmp'
DEFAULT_EXTENSION = 'txt'


def generate_uuid() -> str:
    return str(uuid.uuid4())


def create_tmp_file(path: str = DEFAULT_FOLDER + '/', *, name: str = None, ext: str = DEFAULT_EXTENSION):
    file_name = name or generate_uuid()
    path = create_file_path(file_name, ext, path=path)
    write_file(path, [])
    return path


def create_file_path(name=None, ext='', path=DEFAULT_FOLDER, *, skip_make_folder=False):
    name = name or generate_uuid()
    not skip_make_folder and os.makedirs(path, exist_ok=True)
    return join_path(path, name + ('.' + ext if ext else ''))


def create_directory(path: str = DEFAULT_FOLDER, name: str = None):
    dir_name = name or generate_uuid()
    dir_path = join_path(path, dir_name)
    try:
        os.mkdir(dir_path)
    except FileExistsError:
        pass
    return dir_path


def create_all_path_dirs(dir_path: str) -> str:
    os.makedirs(dir_path, exist_ok=True)
    return dir_path


def join_path(*args) -> str:
    return os.path.join(*args)


def combine_files(*args) -> str:
    output = create_tmp_file()
    call_subprocess(f'cat {" ".join(args)} > {output}')
    return output


def path_exists(entity_path) -> bool:
    return path.exists(entity_path)


def mv_file(file_path: str, new_path: str, new_name: str = None):
    new_name = new_name or os.path.basename(file_path)
    result_path = join_path(new_path, new_name)
    shutil.move(file_path, result_path)


def remove_folder(dir_path: str, *, ignore_errors=False):
    shutil.rmtree(dir_path, ignore_errors=ignore_errors)


def remove_folder_content(dir_path: str, *, ignore_errors=False):
    for root, dirs, files in os.walk(dir_path):
        for f in files:
            os.unlink(os.path.join(root, f))
        for d in dirs:
            shutil.rmtree(os.path.join(root, d))


def remove_file(file_path: str):
    if file_exists(file_path):
        os.remove(file_path)


@dataclass(frozen=True)
class DirEntry:
    path: str
    name: str


def read_directory_files(dir_path: str, *, recursive: bool = False) -> List[DirEntry]:
    if recursive:
        files_list = []
        for root, dirs, files in os.walk(dir_path):
            for file in files:
                files_list.append(DirEntry(path=join_path(root, file), name=file))
        return files_list

    return [DirEntry(path=f.path, name=f.name) for f in scandir(dir_path) if f.is_file()]


def read_directory_dirs(dir_path: str) -> List[DirEntry]:
    return [DirEntry(path=f.path, name=f.name) for f in scandir(dir_path) if f.is_dir()]


def get_file_name_from_path(file_path: str, *, extension=False) -> str:
    if not extension:
        return os.path.splitext(os.path.basename(file_path))[0]
    return Path(file_path).name


def read_file(path: str) -> list[str]:
    with open(path, encoding='windows-1252', errors="ignore") as f:
        return f.read().splitlines()


def read_file_only_unique_lines(path: str) -> Set[str]:
    return set(read_file(path))


def safely_read_file(file_path: str) -> Set[str]:
    try:
        return read_file_only_unique_lines(file_path)
    except FileNotFoundError:
        return set()


def safely_read_file_as_string(file_path: str) -> str:
    try:
        return read_file_as_string(file_path)
    except FileNotFoundError:
        return ''


def read_file_as_string(path: str) -> str:
    with open(path, encoding='windows-1252', errors="ignore") as f:
        return f.read()


def file_is_empty(file_path: str) -> bool:
    return os.stat(file_path).st_size == 0


def write_file(path: str, data) -> str:
    write_file_internal(path, 'w', data)
    return path


def create_file(data, path=None) -> str:
    path = path or create_tmp_file()
    return write_file(path, data)


def append_file(path: str, data) -> str:
    write_file_internal(path, 'a', data)
    return path


def get_file_size(path: str) -> int:
    return Path(path).stat().st_size


def get_folder_size(path: str) -> int:
    total = 0
    for entry in os.scandir(path):
        if entry.is_file():
            total += entry.stat().st_size
        elif entry.is_dir():
            total += get_folder_size(entry.path)
    return total


def write_file_internal(path, mode, data):
    with open(path, mode) as f:
        if is_iterable(data) and not isinstance(data, str):
            for item in data:
                f.write("%s\n" % item)
        else:
            try:
                f.write("%s\n" % data)
            except UnicodeEncodeError:
                f.write("%s\n" % data.encode('utf-8', 'replace').decode())


def clean_subdirs(subdirs):
    return set([x[1:] if x.startswith('/') else x for x in subdirs])


def create_zip(out_path, dir_path):
    return shutil.make_archive(out_path, 'zip', dir_path)


def copy_file(source, dst=None) -> str:
    dst = dst or create_tmp_file()
    shutil.copyfile(source, dst)
    return dst


def file_exists(file_path: str) -> bool:
    return os.path.isfile(file_path)


def remove_strings_if_match_any(path: str, matches: List[str]) -> str:
    output_path = create_tmp_file()
    sed_command = ' | sed /' + matches[0] + '/d '
    for match in matches[1:]:
        sed_command += ' | sed /' + match + '/d '
    call_subprocess('cat ' + path + sed_command + ' > ' + output_path)
    return output_path


def tmp_file(file_name='temp_file', *, ext=None):
    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            file_path = create_tmp_file(ext=ext)
            kwargs[file_name] = file_path
            try:
                result = func(*args, **kwargs)
            finally:
                remove_file(file_path)
            return result

        return wrapper

    return actual_decorator


def tmp_folder(folder_name='temp_folder'):
    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            folder_path = create_directory()
            kwargs[folder_name] = folder_path
            try:
                result = func(*args, **kwargs)
            finally:
                remove_folder(folder_path, ignore_errors=True)
            return result

        return wrapper

    return actual_decorator


def tmp_folders(folders_name='folders', n: int = 1):
    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            folders: List[str] = []
            for i in range(n):
                folders.append(create_directory())
            kwargs[folders_name] = folders
            try:
                result = func(*args, **kwargs)
            finally:
                for folder in folders:
                    remove_folder(folder, ignore_errors=True)
            return result

        return wrapper

    return actual_decorator


def get_file_extension(file_name: str) -> str:
    if not file_name:
        return ''
    extension = os.path.splitext(file_name)[1]
    return extension[1:].lower() if extension else ''


def get_directory_size(directory: str) -> int:
    """Returns the `directory` size in bytes."""
    total = 0
    try:
        # print("[+] Getting the size of", directory)
        for entry in os.scandir(directory):
            if entry.is_file():
                # if it's a file, use stat() function
                total += entry.stat().st_size
            elif entry.is_dir():
                # if it's a directory, recursively call this function
                total += get_directory_size(entry.path)
    except NotADirectoryError:
        # if `directory` isn't a directory, get the file size then
        return os.path.getsize(directory)
    except PermissionError:
        # if for whatever reason we can't open the folder, return 0
        return 0
    return total


def copytree(src, dst, symlinks=False, ignore=None):
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if os.path.isdir(s):
            shutil.copytree(s, d, symlinks, ignore, dirs_exist_ok=True)
        else:
            shutil.copy2(s, d)


def get_all_files_in_tree(dir_path: str) -> List[str]:
    files = os.listdir(dir_path)
    all_files = list()
    for entry in files:
        entry_path = os.path.join(dir_path, entry)
        if os.path.isdir(entry_path):
            all_files.extend(get_all_files_in_tree(entry_path))
        else:
            all_files.append(entry_path)

    return all_files


def get_parent_folder_name(file_or_folder_path: str) -> str:
    return str(Path(file_or_folder_path).parent.absolute())


def is_abs_path(my_path: str) -> bool:
    return os.path.isabs(my_path)
