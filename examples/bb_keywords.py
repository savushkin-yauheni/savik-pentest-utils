import os
import sys

sys.path.append(os.getcwd())


# 1. install dependencies, check README
# 4. python3 examples/bb_keywords.py FOLDER_WITH_BBSCOPE_FILES OUT_PATH MIN_TOKEN_SIZE(OPTIONAL)


import dataclasses
import sys
from multiprocessing import freeze_support
from typing import Dict, List, Set, Tuple

from tldextract import tldextract

from utils.collections_utils import flat_list_of_lists
from utils.io_utils import get_file_extension, read_directory_files, read_file_as_string, write_file
from utils.json_utils import parse_to_json
from utils.string_utils import remove_non_ascii, remove_substring, replace_last
from utils.url_utils import extract_all_domain_names, extract_all_urls, get_fqdn, get_registered_domain, \
    get_url_path_parts, is_domain_name, \
    is_url, with_protocol

MIN_SIZE_FOR_TOKEN = 4

BBSCOPE_DISABLED_3_PARTIES = [
    'apps.apple.com', 'marketplace.atlassian.com', 'addons.mozilla.org',
    'appgallery.huawei.com', 'www.npmjs.com', 'itunes.apple.com', 'immunefi.com',
]

BBSCOPE_DISABLED_REG_DOMAINS_3_PARTIES = [
    'amazonaws.com', 'appspot.com', 'firebaseapp.com', 'firebaseio.com', 'in-addr.arpa', 'tronscan.org',
    'images-iherb.com', 'polygonscan.com', 'googleusercontent.com',
]


@dataclasses.dataclass(frozen=True)
class ProgramAsset:
    name: str
    category: str

    @classmethod
    def from_json(cls, data):
        name = data['name']
        category = data['category']
        return cls(name=name, category=category)


@dataclasses.dataclass(frozen=True)
class Program:
    name: str
    url: str
    assets: List[ProgramAsset] = dataclasses.field(default_factory=list)

    @classmethod
    def from_json(cls, data):
        name = data['name']
        url = data['url']
        assets = list(map(
            ProgramAsset.from_json,
            data['assets'],
        )) if 'assets' in data and data['assets'] else []
        return cls(name=name, url=url, assets=assets)


def read_bbscope_files_and_return_programs() -> List[Program]:
    bbscope_files = read_directory_files(folder_path)
    all_programs = []
    for bbscope_file in bbscope_files:
        bbscope_file_content = read_file_as_string(bbscope_file.path)
        bbscope_programs = parse_to_json(bbscope_file_content)

        converted_programs = list(
            map(
                Program.from_json,
                bbscope_programs,
            ))

        all_programs.extend(transform_programs(converted_programs))

    return all_programs


def extract_valid_domains_from_platform_string(row: str) -> Set[str]:
    domains = set()
    rows = row.split(',')
    for token in rows:
        domains.update(extract_from_single_token(token))
    return {domain for domain in domains if domain}


def find_symbol_pairs(s: str, start_symbol: str, finish_symbol: str) -> List[Tuple[int, int]]:
    """
    Find start and finish indices of symbol pairs in a string.

    Args:
    - s (str): The input string.
    - start_symbol (str): The starting symbol.
    - finish_symbol (str): The finishing symbol.

    Returns:
    - List[Tuple[int, int]]: List of (start, finish) index pairs.
    """
    start_indices = [i for i, char in enumerate(s) if char == start_symbol]
    finish_indices = [i for i, char in enumerate(s) if char == finish_symbol]

    # Pair the start and finish indices
    if len(start_indices) != len(finish_indices):
        raise ValueError("Number of start symbols and finish symbols do not match.")

    return list(zip(start_indices, finish_indices))


def extract_multi_tlds_assets(row: str) -> Set[str]:
    row = row.replace('http://', '') if row.startswith('http://') else row
    row = row.replace('https://', '') if row.startswith('https://') else row
    start_symbol = ''
    finish_symbol = ''
    if '(' in row:
        start_symbol = '('
        finish_symbol = ')'
    elif '[' in row:
        start_symbol = '['
        finish_symbol = ']'
    else:
        raise ValueError(f'[extract_multi_tlds_assets] invalid data: {row}')

    row = row.replace(f'{finish_symbol}{finish_symbol}', finish_symbol)

    while True:
        all_pairs = find_symbol_pairs(row, start_symbol, finish_symbol)
        if len(all_pairs) <= 1:
            break
        for start_idx, end_idx in all_pairs:
            if '|' not in row[start_idx:end_idx]:
                row = remove_substring(row, start_idx, end_idx)
    row = row.strip()

    left_part_start_index = 0
    left_part_finish_index = 0
    right_part_start_index = len(row) - 1
    right_part_finish_index = len(row)

    start_symbol_index = row.index(start_symbol)
    if start_symbol_index > 0:
        left_part_finish_index = start_symbol_index

    finish_symbol_index = row.index(finish_symbol)
    if finish_symbol_index < len(row) - 1:
        right_part_start_index = finish_symbol_index + 1
    else:
        right_part_finish_index = right_part_finish_index - 1

    tld_parts = row[start_symbol_index + 1:finish_symbol_index].split('|')
    assets = {
        f'{row[left_part_start_index:left_part_finish_index]}{tld}{row[right_part_start_index:right_part_finish_index]}'
        for tld in tld_parts}

    return assets


def extract_from_single_token(domain: str) -> Set[str]:
    domain = domain.strip()
    transformed_domains = set()
    domain = remove_non_ascii(domain).strip().lower()
    if '{' in domain or '*-' in domain or '-*' in domain or 'yourdomain' in domain or 'yourcompany' in domain \
            or 'yoursubdomain' in domain or 'your-subdomain' in domain or 'your_instance_name' in domain \
            or '<' in domain or '*dev*' in domain or 'your_subdomain' in domain or not domain:
        return set()
    domain = replace_last(domain, '/*', '') if domain.endswith('/*') else domain
    domain = domain.replace(' (+++)', '') if domain.endswith(' (+++)') else domain
    domain = domain.replace(' (++)', '') if domain.endswith(' (++)') else domain
    domain = domain.replace(' (+)', '') if domain.endswith(' (+)') else domain
    if domain.startswith('*.'):
        if domain.count('*.') == 1:
            domain = domain.replace('*.', '')
            if '(' in domain and '|' in domain:
                transformed_domains.update(extract_multi_tlds_assets(domain))
            else:
                transformed_domains.update(extract_all_domain_names(domain))
    elif ('(' in domain and '|' in domain) or ('[' in domain and '|' in domain):
        transformed_domains.update(extract_multi_tlds_assets(domain))
    elif domain.startswith('*'):
        if is_domain_name(domain[1:]):
            transformed_domains.add(domain[1:])
    elif domain.startswith('http://*.'):
        if not get_url_path_parts(domain):
            transformed_domains.add(domain.replace('http://*.', '').replace('/', ''))
    elif domain.startswith('https://*.'):
        if not get_url_path_parts(domain):
            transformed_domains.add(domain.replace('https://*.', '').replace('/', ''))
    elif domain.startswith('wss://'):
        main_part = domain.replace('wss://', '')
        if not get_url_path_parts(with_protocol(main_part)):
            transformed_domains.add(main_part.replace('/', ''))
    elif is_url(domain):
        if not get_url_path_parts(domain):
            transformed_domains.add(get_fqdn(domain))
    elif is_url(with_protocol(domain)):
        if not get_url_path_parts(with_protocol(domain)):
            transformed_domains.add(get_fqdn(with_protocol(domain)))
    else:
        domain = domain.replace('(', '').replace(')', '')
        if extract_all_urls(domain):
            urls = extract_all_urls(domain)
            for url in urls:
                if not get_url_path_parts(url):
                    transformed_domains.add(get_fqdn(url))
        elif is_domain_name(domain):
            transformed_domains.add(domain)
        elif '*.' in domain:
            pass
        elif domain.startswith('https:'):
            transformed_domains.add(domain.replace('https:', ''))
        elif domain.startswith('http:'):
            transformed_domains.add(domain.replace('http:', ''))
        else:
            pass
    return transformed_domains


def transform_programs(parsed_programs: List[Program]) -> List[Program]:
    transformed_programs: List[Program] = []
    for program in parsed_programs:
        name = remove_non_ascii(program.name.strip())
        parsed_assets = program.assets
        extracted_asset_to_programs_assets: Dict[str, Set[ProgramAsset]] = {}
        for parsed_asset in parsed_assets:
            assets_from_platform_asset_string = extract_valid_domains_from_platform_string(parsed_asset.name)
            if assets_from_platform_asset_string:
                for asset in assets_from_platform_asset_string:
                    if get_file_extension(asset) in ['exe', 'onion']:
                        continue
                    if get_fqdn(asset) in BBSCOPE_DISABLED_3_PARTIES:
                        continue
                    if get_registered_domain(asset) in BBSCOPE_DISABLED_REG_DOMAINS_3_PARTIES:
                        continue
                    extracted_asset_to_programs_assets.setdefault(asset, set()).add(parsed_asset)

        if extracted_asset_to_programs_assets:
            transformed_programs.append(
                Program(
                    name=name, url=program.url, assets=flat_list_of_lists(extracted_asset_to_programs_assets.values()),
                )
            )

    return transformed_programs


def parse_token_to_keywords(token: str, token_min_size: int) -> Set[str]:
    parts = set()
    if is_domain_name(token):
        parts.add(tldextract.extract(token).domain)
    else:
        parts.add(token)

    result = set()
    for part in parts:
        if '-' in part:
            new_parts = part.split('-')
            for new_part in new_parts:
                result.update(parse_token_to_keywords(new_part, token_min_size))
        elif ' ' in part:
            pass
        else:
            if len(part) > token_min_size:
                result.add(part.lower())
    return result


def generate_wordlist_from_programs(programs: List[Program], token_min_size: int) -> Set[str]:
    generated_wordlist = set()
    for program in programs:
        program_assets = program.assets
        generated_wordlist.update(parse_token_to_keywords(program.name, token_min_size))
        for program_asset in program_assets:
            program_asset_name = program_asset.name
            token = ''
            if is_url(program_asset_name):
                token = get_fqdn(program_asset_name)
            elif is_domain_name(program_asset_name):
                token = program_asset_name
            if token:
                generated_wordlist.update(parse_token_to_keywords(token, token_min_size))
    return generated_wordlist


if __name__ == '__main__':
    freeze_support()

    # Check if the file path is provided as a command-line argument
    if len(sys.argv) < 3:
        print("Please provide the input folder path and output file as a command-line argument.")
        sys.exit(1)

    folder_path = sys.argv[1]
    output_file = sys.argv[2]
    token_min_size = MIN_SIZE_FOR_TOKEN
    if len(sys.argv) > 3:
        token_min_size = int(sys.argv[3])

    programs = read_bbscope_files_and_return_programs()
    wordlist = generate_wordlist_from_programs(programs, token_min_size)
    write_file(output_file, sorted(wordlist))